<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Locitorium</title>
    <meta name="description" content="Text-to-Geospatial service that using Ollama for semantic extracting and Nominatim (OpenStreetMap) for grounding to eliminate hallucinations." />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Locitorium" />
    <meta property="og:description" content="Text-to-Geospatial service that using Ollama for semantic extracting and Nominatim (OpenStreetMap) for grounding to eliminate hallucinations." />
    <meta property="og:site_name" content="Locitorium" />
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Locitorium" />
    <meta name="twitter:description" content="Text-to-Geospatial service that using Ollama for semantic extracting and Nominatim (OpenStreetMap) for grounding to eliminate hallucinations." />
    
    <link rel="stylesheet" href="/static/index.css" />
    <link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>
  </head>
  <body>
    <header>
      <h1>Locitorium</h1>
      <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem; opacity: 0.9;">Text-to-Geospatial service that using Ollama for semantic extracting and Nominatim (OpenStreetMap) for grounding to eliminate hallucinations.</p>
    </header>
    
    <div class="container">
      <div class="left-panel">
        <section class="section" id="playground">
          <div class="section-title">
            <span class="section-emoji">üìù</span>
            <h2>Playground</h2>
          </div>
          <p class="section-desc">Enter text to resolve locations.</p>
          <form id="resolveForm">
            <label for="q">Text</label>
            <textarea id="q" name="q" placeholder="Paste text here..."></textarea>
            
            <label for="model">Model (optional)</label>
            <select id="model" name="model">
              <option value="granite4:3b" selected>granite4:3b</option>
              <option value="granite4:1b-h">granite4:1b-h</option>
              <option value="granite3.3:2b">granite3.3:2b</option>
              <option value="granite3.2:8b">granite3.2:8b</option>
              <option value="ministral-3:3b">ministral-3:3b</option>
            </select>
            
            <button type="submit" id="submitBtn">Resolve Locations</button>
          </form>
        </section>
      </div>
      
      <div class="right-panel">
        <section class="section" id="resultsSection">
          <div class="section-title">
            <span class="section-emoji">üó∫Ô∏è</span>
            <h2>Playground Results</h2>
          </div>
          <div class="empty-state" id="emptyState">
            <div class="empty-state-icon">üó∫Ô∏è</div>
            <h3>No results yet</h3>
            <p>Enter text in the left panel and click "Resolve Locations" to get started.</p>
          </div>
          
          <div class="spinner-container" id="spinnerContainer">
            <div class="spinner"></div>
          </div>
          
          <div id="mapContainer" style="display: none;">
            <div id="map"></div>
          </div>
          
          <div id="results"></div>
        </section>
      </div>
    </div>

    <section class="section docs" id="docs">
      <div class="section-title">
        <span class="section-emoji">üìö</span>
        <h2>API Documentation</h2>
      </div>
      
      <div class="docs-content">
        <div class="docs-section">
          <h3>Resolve locations from text</h3>
          <p>Extract and resolve location mentions from unstructured text using LLM-based extraction and OpenStreetMap grounding.</p>
          
          <div class="endpoint-box">
            <span class="http-method">GET</span>
            <code class="endpoint-path">/api</code>
          </div>
        </div>

        <div class="docs-section">
          <h3>Parameters</h3>
          <table class="params-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Required</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>q</code></td>
                <td>string</td>
                <td><span class="badge-required">Required</span></td>
                <td>The text to analyze for location mentions. Must be at least 1 character and no more than 2000 characters.</td>
              </tr>
              <tr>
                <td><code>model</code></td>
                <td>string</td>
                <td><span class="badge-optional">Optional</span></td>
                <td>Ollama model name (e.g., <code>granite3.3:2b</code>, <code>granite4:3b</code>). Defaults to <code>granite3.3:2b</code>.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="docs-section">
          <h3>Response</h3>
          <p>Returns a JSON object containing resolved location information.</p>
          
          <h4>Response Schema</h4>
          <table class="params-table">
            <thead>
              <tr>
                <th>Field</th>
                <th>Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>doc_id</code></td>
                <td>string</td>
                <td>Unique identifier for this request.</td>
              </tr>
              <tr>
                <td><code>model_info</code></td>
                <td>object</td>
                <td>Metadata about the models and services used (see ModelInfo below).</td>
              </tr>
              <tr>
                <td><code>results</code></td>
                <td>array</td>
                <td>List of resolved location mentions (see Result Object below).</td>
              </tr>
            </tbody>
          </table>

          <h4>ModelInfo Object</h4>
          <table class="params-table">
            <thead>
              <tr>
                <th>Field</th>
                <th>Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>ollama_model</code></td>
                <td>string</td>
                <td>Name of the Ollama model used for extraction.</td>
              </tr>
              <tr>
                <td><code>ollama_base_url</code></td>
                <td>string</td>
                <td>Base URL of the Ollama service.</td>
              </tr>
              <tr>
                <td><code>nominatim_base_url</code></td>
                <td>string</td>
                <td>Base URL of the Nominatim (OpenStreetMap) service.</td>
              </tr>
              <tr>
                <td><code>config_hash</code></td>
                <td>string</td>
                <td>Hash of the configuration used for this request.</td>
              </tr>
            </tbody>
          </table>

          <h4>Result Object</h4>
          <table class="params-table">
            <thead>
              <tr>
                <th>Field</th>
                <th>Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>mention_id</code></td>
                <td>string</td>
                <td>Unique identifier for this mention.</td>
              </tr>
              <tr>
                <td><code>mention</code></td>
                <td>string</td>
                <td>The extracted place name from text.</td>
              </tr>
              <tr>
                <td><code>status</code></td>
                <td>string</td>
                <td>Resolution status: <code>resolved</code>, <code>no_candidate</code>, <code>rejected</code>, <code>invalid_output</code>, or <code>timeout</code>.</td>
              </tr>
              <tr>
                <td><code>selected</code></td>
                <td>object | null</td>
                <td>The best matching location candidate (see SelectedCandidate below). Null if status is not <code>resolved</code>.</td>
              </tr>
              <tr>
                <td><code>candidates</code></td>
                <td>array</td>
                <td>Ranked list of alternative location candidates (see Candidate below).</td>
              </tr>
            </tbody>
          </table>

          <h4>SelectedCandidate Object</h4>
          <table class="params-table">
            <thead>
              <tr>
                <th>Field</th>
                <th>Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>osm_type</code></td>
                <td>string</td>
                <td>OpenStreetMap type (e.g., <code>relation</code>, <code>way</code>, <code>node</code>).</td>
              </tr>
              <tr>
                <td><code>osm_id</code></td>
                <td>integer | string</td>
                <td>OpenStreetMap ID.</td>
              </tr>
              <tr>
                <td><code>lat</code></td>
                <td>float | string</td>
                <td>Latitude coordinate.</td>
              </tr>
              <tr>
                <td><code>lon</code></td>
                <td>float | string</td>
                <td>Longitude coordinate.</td>
              </tr>
              <tr>
                <td><code>bbox</code></td>
                <td>array</td>
                <td>Bounding box as [min_lat, max_lat, min_lon, max_lon].</td>
              </tr>
              <tr>
                <td><code>display_name</code></td>
                <td>string</td>
                <td>Human-readable location name.</td>
              </tr>
              <tr>
                <td><code>country_code</code></td>
                <td>string | null</td>
                <td>ISO 3166-1 alpha-2 country code (uppercase).</td>
              </tr>
              <tr>
                <td><code>confidence</code></td>
                <td>float | null</td>
                <td>Confidence score for the selection.</td>
              </tr>
            </tbody>
          </table>

          <h4>Candidate Object</h4>
          <table class="params-table">
            <thead>
              <tr>
                <th>Field</th>
                <th>Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>rank</code></td>
                <td>integer</td>
                <td>Ranking position (1 = best).</td>
              </tr>
              <tr>
                <td><code>osm_type</code></td>
                <td>string</td>
                <td>OpenStreetMap type.</td>
              </tr>
              <tr>
                <td><code>osm_id</code></td>
                <td>integer | string</td>
                <td>OpenStreetMap ID.</td>
              </tr>
              <tr>
                <td><code>display_name</code></td>
                <td>string</td>
                <td>Human-readable location name.</td>
              </tr>
              <tr>
                <td><code>lat</code></td>
                <td>float | string</td>
                <td>Latitude coordinate.</td>
              </tr>
              <tr>
                <td><code>lon</code></td>
                <td>float | string</td>
                <td>Longitude coordinate.</td>
              </tr>
              <tr>
                <td><code>bbox</code></td>
                <td>array</td>
                <td>Bounding box coordinates.</td>
              </tr>
              <tr>
                <td><code>country_code</code></td>
                <td>string | null</td>
                <td>ISO 3166-1 alpha-2 country code (uppercase).</td>
              </tr>
              <tr>
                <td><code>category</code></td>
                <td>string | null</td>
                <td>OSM category (e.g., <code>boundary</code>, <code>place</code>).</td>
              </tr>
              <tr>
                <td><code>place_rank</code></td>
                <td>integer | null</td>
                <td>Nominatim place rank.</td>
              </tr>
              <tr>
                <td><code>importance</code></td>
                <td>float | null</td>
                <td>Importance score from Nominatim.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="docs-section">
          <h3>Error Responses</h3>
          <table class="params-table">
            <thead>
              <tr>
                <th>Status Code</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>400</code></td>
                <td>Bad Request - Input text exceeds 2000 characters (<code>input too long</code>).</td>
              </tr>
              <tr>
                <td><code>500</code></td>
                <td>Internal Server Error - Processing failed. Error details in response body.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </section>
    
    <script>
      const form = document.getElementById('resolveForm');
      const spinnerContainer = document.getElementById('spinnerContainer');
      const resultsDiv = document.getElementById('results');
      const emptyState = document.getElementById('emptyState');
      const submitBtn = document.getElementById('submitBtn');
      const mapContainer = document.getElementById('mapContainer');
      
      let map = null;
      
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const q = document.getElementById('q').value.trim();
        const model = document.getElementById('model').value.trim();
        
        if (!q) {
          alert('Please enter text to resolve');
          return;
        }
        
        // Show spinner, hide empty state and results, disable button
        emptyState.style.display = 'none';
        resultsDiv.classList.remove('active');
        resultsDiv.innerHTML = '';
        mapContainer.style.display = 'none';
        spinnerContainer.classList.add('active');
        submitBtn.disabled = true;
        
        try {
          const params = new URLSearchParams({ q });
          if (model) params.append('model', model);
          
          const response = await fetch(`/api?${params.toString()}`);
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          displayResults(data);
          
        } catch (error) {
          resultsDiv.innerHTML = `
            <div class="error">
              <strong>Error:</strong> ${error.message}
            </div>
          `;
          resultsDiv.classList.add('active');
        } finally {
          spinnerContainer.classList.remove('active');
          submitBtn.disabled = false;
        }
      });
      
      function displayResults(data) {
        let html = '';
        
        // Model Info
        if (data.model_info) {
          html += `
            <div class="model-info">
              <div class="model-info-title">Model Information</div>
              <div><strong>Model:</strong> ${data.model_info.ollama_model || 'N/A'}</div>
              <div><strong>Ollama URL:</strong> ${data.model_info.ollama_base_url || 'N/A'}</div>
              <div><strong>Nominatim URL:</strong> ${data.model_info.nominatim_base_url || 'N/A'}</div>
              <div><strong>Config Hash:</strong> ${data.model_info.config_hash || 'N/A'}</div>
              <div><strong>Document ID:</strong> ${data.doc_id || 'N/A'}</div>
            </div>
          `;
        }
        
        // Results
        if (data.results && data.results.length > 0) {
          html += `<h2>Resolved Locations (${data.results.length})</h2>`;
          
          data.results.forEach(result => {
            const statusClass = result.status === 'resolved' ? 'status-resolved' : '';
            
            html += `
              <div class="result-card">
                <div class="result-header">
                  "${result.mention}"
                  <span class="result-status ${statusClass}">${result.status}</span>
                </div>
            `;
            
            if (result.selected) {
              const sel = result.selected;
              const bboxStr = sel.bbox ? `[${sel.bbox.join(', ')}]` : 'N/A';
              html += `
                <div class="result-selected">
                  <div class="result-label">Selected Location:</div>
                  <div class="result-value"><strong>${sel.display_name}</strong></div>
                  <div class="result-value" style="margin-top: 0.5rem;">
                    <strong>Coordinates:</strong> ${sel.lat}, ${sel.lon}
                  </div>
                  <div class="result-value">
                    <strong>BBox:</strong> ${bboxStr}
                  </div>
                  <div class="result-value">
                    <strong>OSM:</strong> ${sel.osm_type} / ${sel.osm_id}
                  </div>
                  <div class="result-value">
                    <strong>Country:</strong> ${sel.country_code || 'N/A'}
                  </div>
                </div>
              `;
            }
            
            if (result.candidates && result.candidates.length > 1) {
              html += `
                <div style="margin-top: 0.75rem; font-size: 0.9rem; color: #666;">
                  <strong>Other candidates:</strong> ${result.candidates.length - 1}
                </div>
              `;
            }
            
            html += `</div>`;
          });
        } else {
          html += `<div class="result-card">No locations found.</div>`;
        }
        
        resultsDiv.innerHTML = html;
        resultsDiv.classList.add('active');
        
        // Initialize map and add markers
        initializeMap(data);
      }
      
      function initializeMap(data) {
        // Collect all resolved locations with bbox
        const locations = [];
        if (data.results) {
          data.results.forEach(result => {
            if (result.status === 'resolved' && result.selected) {
              const sel = result.selected;
              if (sel.bbox && sel.bbox.length === 4) {
                const [minLat, maxLat, minLon, maxLon] = sel.bbox.map(v => parseFloat(v));
                
                // Calculate center coordinates
                // For bboxes that cross the dateline (lon span = 360), use the center point
                const lonSpan = maxLon - minLon;
                const centerLon = lonSpan === 360 ? parseFloat(sel.lon) : (minLon + maxLon) / 2;
                const centerLat = (minLat + maxLat) / 2;
                
                // Skip if bbox spans more than 90 degrees in latitude (likely data error)
                const latSpan = maxLat - minLat;
                if (latSpan > 90) {
                  console.warn(`Skipping invalid bbox (lat span > 90) for ${result.mention}:`, sel.bbox);
                  return;
                }
                
                // For dateline-crossing bboxes (lonSpan = 360), only show label, no bbox polygon
                const showPolygon = lonSpan < 360;
                
                locations.push({
                  bbox: [minLon, minLat, maxLon, maxLat], // [west, south, east, north]
                  center: [centerLon, centerLat],
                  name: sel.display_name,
                  mention: result.mention,
                  id: result.mention_id,
                  showPolygon: showPolygon
                });
              }
            }
          });
        }
        
        if (locations.length === 0) {
          mapContainer.style.display = 'none';
          return;
        }
        
        // Show map container
        mapContainer.style.display = 'block';
        
        // Initialize map if not already created
        if (!map) {
          map = new maplibregl.Map({
            container: 'map',
            style: 'https://tile.openstreetmap.jp/styles/osm-bright/style.json',
            center: locations[0].center,
            zoom: 5,
            attributionControl: true
          });
          
          // Add attribution
          map.addControl(new maplibregl.AttributionControl({
            compact: false
          }));
        }
        
        // Wait for map to load before adding layers
        map.once('load', () => {
          // Remove existing layers and sources if they exist
          if (map.getLayer('bbox-layer')) map.removeLayer('bbox-layer');
          if (map.getLayer('bbox-outline')) map.removeLayer('bbox-outline');
          if (map.getLayer('bbox-labels')) map.removeLayer('bbox-labels');
          if (map.getSource('bboxes')) map.removeSource('bboxes');
          
          // Create GeoJSON features for bboxes (only for locations that should show polygon)
          const features = locations
            .filter(loc => loc.showPolygon)
            .map(loc => {
              const [minLon, minLat, maxLon, maxLat] = loc.bbox;
              return {
                type: 'Feature',
                properties: {
                  name: loc.name,
                  mention: loc.mention,
                  id: loc.id
                },
                geometry: {
                  type: 'Polygon',
                  coordinates: [[
                    [minLon, minLat],
                    [maxLon, minLat],
                    [maxLon, maxLat],
                    [minLon, maxLat],
                    [minLon, minLat]
                  ]]
                }
              };
            });
          
          // Create GeoJSON features for labels
          const labelFeatures = locations.map(loc => ({
            type: 'Feature',
            properties: {
              name: loc.name,
              mention: loc.mention
            },
            geometry: {
              type: 'Point',
              coordinates: loc.center
            }
          }));
          
          // Add source
          map.addSource('bboxes', {
            type: 'geojson',
            data: {
              type: 'FeatureCollection',
              features: [...features, ...labelFeatures]
            }
          });
          
          // Add bbox fill layer
          map.addLayer({
            id: 'bbox-layer',
            type: 'fill',
            source: 'bboxes',
            filter: ['==', ['geometry-type'], 'Polygon'],
            paint: {
              'fill-color': '#3498db',
              'fill-opacity': 0.2
            }
          });
          
          // Add bbox outline layer
          map.addLayer({
            id: 'bbox-outline',
            type: 'line',
            source: 'bboxes',
            filter: ['==', ['geometry-type'], 'Polygon'],
            paint: {
              'line-color': '#2980b9',
              'line-width': 2
            }
          });
          
          // Add label layer
          map.addLayer({
            id: 'bbox-labels',
            type: 'symbol',
            source: 'bboxes',
            filter: ['==', ['geometry-type'], 'Point'],
            layout: {
              'text-field': ['get', 'mention'],
              'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
              'text-size': 16,
              'text-anchor': 'center',
              'text-offset': [0, 0]
            },
            paint: {
              'text-color': '#ffffff',
              'text-halo-color': '#2980b9',
              'text-halo-width': 3,
              'text-halo-blur': 1
            }
          });
          
          // Add click handler for bbox
          map.on('click', 'bbox-layer', (e) => {
            if (e.features && e.features.length > 0) {
              const feature = e.features[0];
              new maplibregl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(`
                  <div style="font-family: sans-serif;">
                    <strong>${feature.properties.mention}</strong><br/>
                    ${feature.properties.name}
                  </div>
                `)
                .addTo(map);
            }
          });
          
          // Change cursor on hover
          map.on('mouseenter', 'bbox-layer', () => {
            map.getCanvas().style.cursor = 'pointer';
          });
          
          map.on('mouseleave', 'bbox-layer', () => {
            map.getCanvas().style.cursor = '';
          });
          
          // Fit map to all locations
          const bounds = new maplibregl.LngLatBounds();
          locations.forEach(loc => {
            if (loc.showPolygon) {
              // For normal bboxes, include the entire bbox
              const [minLon, minLat, maxLon, maxLat] = loc.bbox;
              bounds.extend([minLon, minLat]);
              bounds.extend([maxLon, maxLat]);
            } else {
              // For dateline-crossing locations, just include the center point
              bounds.extend(loc.center);
            }
          });
          
          map.fitBounds(bounds, { padding: 50, maxZoom: 12 });
        });
        
        // If map already loaded, trigger immediately
        if (map.loaded()) {
          map.fire('load');
        }
      }
    </script>
  </body>
</html>
